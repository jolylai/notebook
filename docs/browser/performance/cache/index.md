---
title: 缓存
group:
  title: 性能优化
---

## 前言

使用缓存的 2 个主要原因：

- 🚀 降低延迟：缓存离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，呈现速度更快，网站就显得更灵敏。
- 降低网络传输：副本被重复使用，大大降低了用户的带宽使用，其实也是一种变相的省钱（如果流量要付费的话），同时保证了带宽请求在一个低水平上，更容易维护了。

## 刷新操作

| 类型     | 操作                                 | 缓存                       |
| -------- | ------------------------------------ | -------------------------- |
| 正常操作 | 地址栏输入 URL，跳转连接，前进后退等 | 强制缓存有效，协商缓存有效 |
| 手动刷新 | F5，点击刷新按钮、右键菜单刷新       | 强制缓存失效，协商缓存有效 |
| 强制刷新 | control + F5                         | 强制缓存失效，协商缓存失效 |

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存；否则，向服务器发起请求并携带缓存标识。根据是否需向服务器发起 HTTP 请求，将缓存过程划分为两部分：强制缓存和协商缓存，强缓存优先于协商缓存。
HTTP 缓存都是从第二次请求开始的。

1. 第一次请求资源时，服务器返回资源，并且在 `response header` 中回传资源的缓存策略
2. 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接 200，否则把请求参数加到 `request header` 中传给服务器，看是否击中了协商缓存，击中则返回 `304`，否则服务器会返回新的资源。

## 强缓存

服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接使用缓存，不在时间内，执行协商缓存策略。
强缓存命中则直接读取浏览器本地资源，在 network 中显示的是 `from memory` 或 `from disk`。
控制强缓存的字段有：`Cache-Control`（http1.1）和 `Expires`（http1.0）

- Cache-Control 是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间内缓存有效
- Expires 是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求
- Cache-Control 的优先级高于 Expires。前者的出现是为解决后者在浏览器时间被手动更改导致缓存判断错误的问题

### Expires

Expires 响应头包含日期/时间， 即在此时候之后，响应过期。

```
expires: Thu, 12-Aug-2021 02:56:18 GMT
```

该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中读取数据。

Expires 是 HTTP1.0 的字段，表示缓存到期时间是一个绝对时间（当前时间+缓存时间）。响应消息头中，设置这个字段后，就可以告知浏览器在未过期之前不需要再次请求。

由于是绝对时间，所以用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。当然，时差或误差也可能会引起时间不一致，导致缓存失效。

优点：

- 可以在 HTTP1.0 和 1.1 中使用，简单易用
- 以时刻标识失效时间

缺点：

- 是经由服务器发送的（UTC），如果服务器时间和客户端时间存在不一致，会出现问题
- 存在版本问题，到期之前的修改客户端是不可

### Cache-Control

多个指令以逗号分隔。

```
cache-control: private, no-cache, no-store, must-revalidate, max-age=0
```

由于 Expires 存在的问题，HTTP/1.1 增加了 Cache-Control 字段，表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。与 Expires 的区别是，它是相对时间。

- `max-age`：最大有效时间
- `must-revalidate`：如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效
- `no-cache`：不使用强制缓存，需要与服务器验证缓存是否新鲜
- `no-store`：真正的“不要缓存”。所有内容都不走缓存，包括强制和对比。
- `public`：所有的内容都可以被缓存（包括客户端和代理服务器，如 CDN）
- `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

要注意的就是 no-cache 和 no-store 的区别，no-cache 是跳过强缓存，还是会走协商缓存的步骤，而 no-store 是真正的完全不走缓存，所有资源都不会缓存在本地
该字段可以在请求头或响应头设置。

#### 禁止缓存

有资源都不会缓存在本地,发送如下响应头可以关闭缓存。

```
Cache-Control: no-store
```

#### 缓存静态资源

对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS 文件和 JavaScript 文件。另请参阅 Expires 标题。

```
Cache-Control:public, max-age=31536000
```

#### 需要重新验证

指定 no-cache 或 max-age=0, must-revalidate 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。

```
Cache-Control: no-cache

Cache-Control: max-age=0, must-revalidate
```

优点：

- HTTP/1.1 产物，以时间间隔标识失效时间，解决了 Expires 的问题
- 有更多的选项设置

缺点：

- 存在版本问题，到期之前的修改客户端是不可

如果在 Cache-Control 响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。

## 协商缓存

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 并且会显示一个 Not Modified 的字符串。

```
HTTP/1.1 304 Not Modified
```

客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的 `Etag` 和 `Last-Modified` 通过请求发送给服务器，由服务器校验，返回 `304` 状态码时，浏览器直接使用缓存。

- 协商缓存的状态码由服务器决策返回 `200` 或者 `304`
- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置设置了 `If-Modified-Since` 或者 `If-None-Match` 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 `304` 状态，加载浏览器缓存，并且响应头会设置 `Last-Modified` 或者 `Etag` 属性
- 对比缓存在请求数上和没有缓存是一致的，但如果是 `304` 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此在响应体体积上的节省是它的优化点
- 协商缓存有 2 组字段（不是两个），控制协商缓存的字段有 Last-Modified/If-Modified-Since（http1.0) 和 Etag/If-None-Match（http1.1）
- Last-Modified/If-Modified-Since 表示的是服务器资源最后一次修改的时间；Etag/If-None-Match 表示的是服务器资源的唯一标识，只要资源变化，Etag 就会重新生成。
- Etag/If-None-Match 的优先级高于 Last-Modified/If-Modified-Since

### Last-Modified/If-Modified-Since

- 服务器通过 Last-Modified 字段告知浏览器，资源最后一次被修改的时间，例如，Last-Modified：Mon，10 Nov 2019 09:12:11 GMT
- 浏览器将这个值和内容一起记录在缓存数据库中
- 下一次请求相同资源时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段
- 服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比，如果相等则表示未修改，响应 `304`，否表示修改了，响应 200，并携带数据。

优点：

- 不存在版本问题，每次请求都会去服务器校验，服务器对比最后修改时间，如果相同则响应 `304`，不同则返回 200 及资源内容

缺点：

- 只要资源修改，无论内容是否发生实质性的改变，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上是一样的
- 以时刻作为标识，无法识别一秒内进行多次修改的情况。如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的最小单位是秒
- 某些服务器不能精确的得到文件的最后修改时间
- 如果文件时通过服务器动态生成的，那么该方法的更新时间永远是生成时间，尽管文件可能没有变化，所以起不到缓存的作用

### Etag/If-None-Match

在 HTTP1.1 版本中，服务器通过 `Etag` 来设置响应头缓存标识。`Etag` 的值由服务端生成。`Etag` 的优先级高于 `Last-Modified`

在第一次请求时，服务器会将资源和 `Etag` 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。在第二次请求时，浏览器会将 `Etag` 信息放到 `If-None-Match` 请求头去访问服务器，服务器收到请求后，会将服务器中的文件标识与浏览器发来的标识进行对比，如果不相同，服务器返回更新的资源、新的 `Etag` 和 200 状态码 ，如果相同，服务器返回 304 状态码，浏览器读取缓存。

优点：

- 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况
- 不存在版本问题，每次请求都会去服务器进行校验

缺点：

- 计算 `Etag` 值需要性能损耗
- 分布式服务器存储的情况下，计算 `Etag` 的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时 `Etag` 不匹配的情况

## 缓存类型

浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：

- Service Worker Cache (from ServiceWorker)
- Memory Cache (from memory cache)
- Disk Cache
- Push Cache（是 HTTP2 的新特性）

### Service Worker Cache

Service Worker 是一种独立于主线程之外的 JavaScript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。
Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。
注意 Server Worker 对协议是有要求的，必须以 https 协议为前提

### MemoryCache & Disk Cache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。
内存缓存是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。

Disk Cache 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是它的优势在于存储容量和存储时长。那浏览器如何决定将资源放进内存还是硬盘呢？
从日常开发中，可以总结出这样的规律：资源存不存内存，浏览器秉承的是“节约原则”。

- Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”
- 体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。内存使用率比较高的时候，文件优先进入磁盘。

### Push Cache

`Push Cache` 是指 HTTP2 在 server push 阶段存在的缓存。推送缓存，是一种低级的网络功能-使用网络堆栈的任何东西都可以使用它，有用的关键是一致性和可预测性，这是浏览器缓存的最后一道防线，它是 http/2 中的内容，虽然现在应用的并不广泛，但随着 http/2 的推广，它的应用越来越广泛。

- `Push Cache` 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 `Push Cache`。
- `Push Cache` 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
- 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 `Push Cache`。

## 总结

- 首先强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的 `If-Modified-Since` 或者 `If-None-Match` 字段检查资源是否更新
- 若资源更新，返回资源和 `200` 状态码
- 否则返回 `304`，告诉浏览器直接从缓存获取资源

[浏览器缓存机制](https://www.yuque.com/yijiangxiliu/pwblsg/eze2z6)
[通过 Node.js 实践彻底搞懂强缓存和协商缓存](https://mp.weixin.qq.com/s/H7uKjjzOVwaCSmSU81BA4w)
