---
title: 网络安全
group:
  title: 网络请求与远程资源
---

## XSS:跨站脚本攻击

XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它 XSS。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

这些操作一般可以完成下面这些事情:

- 窃取 Cookie。
- 监听用户行为，比如输入账号密码后直接发送到黑客服务器。
- 修改 DOM 伪造登录表单。
- 在页面中生成浮窗广告。

### 存储型（server 端）

存储型，顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。

场景：见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，服务端将恶意代码从数据库中取出来，拼接在 HTML 中返回给浏览器
3. 用户浏览器在收到响应后解析执行，混在其中的恶意代码也同时被执行
4. 恶意代码窃取用户数据，并发送到指定攻击者的网站，或者冒充用户行为，调用目标网站的接口，执行恶意操作

### 反射型（Server 端）

反射型 XSS 指的是恶意脚本作为网络请求的一部分。
与存储型的区别在于，存储型的恶意代码存储在数据库中，反射型的恶意代码在 `URL` 上

```
http://sanyuan.com?q=<script>alert("你完蛋了")</script>
```

这样，在服务器端会拿到 q 参数,然后将内容返回给浏览器端，浏览器将这些内容作为 HTML 的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。

之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到 HTML 文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。

场景：通过 `URL` 传递参数的功能，如网站搜索、跳转等。

攻击步骤：

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码。
2. 用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 `HTML` 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

### DOM 型(浏览器端）

DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 `JavaScript` 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

场景：通过 URL 传递参数的功能，如网站搜索、跳转等。
攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

预防方案：（防止攻击者提交恶意代码，防止浏览器执行恶意代码）

1. 对数据进行严格的输出编码：如 HTML 元素的编码，JS 编码，CSS 编码，URL 编码等等
   - 避免拼接 HTML；Vue/React 技术栈，避免使用 v-html / dangerouslySetInnerHTML
2. `CSP HTTP Header`，即 `Content-Security-Policy`、`X-XSS-Protection`

- 增加攻击难度，配置 CSP(本质是建立白名单，由浏览器进行拦截)
- Content-Security-Policy: default-src 'self' -所有内容均来自站点的同一个源（不包括其子域名）
- Content-Security-Policy: default-src 'self' \*.trusted.com-允许内容来自信任的域名及其子域名 (域名不必须与 CSP 设置所在的域名相同)
- Content-Security-Policy: default-src https://yideng.com-该服务器仅允许通过HTTPS方式并仅从yideng.com域名来访问文档

3. 输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等做校验判断
4. 开启浏览器 XSS 防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
5. 验证码

## CSRF：跨站请求伪造

**跨站点请求伪造（Cross-site request forgery）** 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

攻击流程举例

1. 受害者登录 a.com，并保留了登录凭证（Cookie）
2. 攻击者引诱受害者访问了 b.com
3. b.com 向 a.com 发送了一个请求：a.com/act=xx 浏览器会默认携带 a.com 的 Cookie
4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
5. a.com 以受害者的名义执行了 act=xx
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作

### 发起 CSRF

1. 自动发 GET 请求

黑客网页里面可能有一段这样的代码:

```html
<img src="https://xxx.com/info?user=hhh&count=100"></img>
```

进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。

假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。

2. 自动发 POST 请求

黑客可能自己填了一个表单，写了一段自动提交的脚本。

```html
<form id="hacker-form" action="http://bank.example/withdraw" method="POST">
  <input type="hidden" name="account" value="xiaoming" />
  <input type="hidden" name="amount" value="10000" />
  <input type="hidden" name="for" value="hacker" />
</form>
<script>
  document.getElementById('hacker-form').submit();
</script>
```

同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。

3. 诱导点击发送 GET 请求

```html
<a href="https://xxx/info?user=hhh&count=100" taget="_blank"
  >点击进入修仙世界</a
>
```

### 防范措施

CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。

阻止不明外域的访问

- 同源检测
- Samesite Cookie

提交时要求附加本域才能获取的信息

- CSRF Token
- 双重 Cookie 验证

#### 验证来源站点

通过请求头中的 `Origin` 、`Referer` 确定，当然，这两者都是可以伪造的，通过 AJAX 中自定义请求头即可，安全性略差。

#### SameSite Cookie

Google 起草了一份草案来改进 HTTP 协议，那就是为 Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie

SameSite 可以设置为三个值，Strict、Lax 和 None。

- 在 Strict 模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求 sanyuan.com 网站只能在 sanyuan.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。
- 在 Lax 模式，就宽松一点了，但是只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
- 在 None 模式下，也就是默认模式，请求会自动携带上 Cookie。

在敏感 cookie 上携带属性 Samesite：Strict 或 Lax，可以避免在第三方不同域网站上携带 cookie

### CSRF Token

首先服务器生成一个动态的 token，传给用户，用户再次提交或者请求敏感操作时，携带此 token，服务端校验通过才返回正确结果。

Django 作为 Python 的一门后端框架，用它开发过的同学就知道，在它的模板(template)中, 开发表单时，经常会附上这样一行代码:

```
{% csrf_token %}
```

这就是 CSRF Token 的典型应用。那它的原理是怎样的呢？

首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。

然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是 CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。

流程

- 步骤 1：在用户访问网站页面时，向请求域名注入一个 `Cookie`，内容为随机字符串（例如 csrfcookie=v8g9e4ksfhw）
- 步骤 2：在前端向后端发起请求时，取出 `Cookie`，并添加到 `URL` 的参数中（接上例 POST `https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）
- 步骤 3：后端接口验证 `Cookie` 中的字段与 `URL` 参数中的字段是否一致，不一致则拒绝。

优点

- 无需使用 Session，适用面更广，易于实施。
- Token 储存于客户端中，不会给服务器带来压力。
- 相对于 Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。

缺点

- Cookie 中增加了额外的字段。
- 如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。
- 难以做到子域名的隔离。
- 为了确保 Cookie 传输安全，采用这种防御方式的最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。

## iframe 安全

说明：

1. 嵌入第三方 iframe 会有很多不可控的问题，同时当第三方 iframe 出现问题或是被劫持之后，也会诱发安全性问题
2. 点击劫持: 攻击者将目标网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，诱导用户点击。
3. 禁止自己的 iframe 中的链接外部网站的 JS

预防方案：

1. 为 iframe 设置 sandbox 属性，通过它可以对 iframe 的行为进行各种限制，充分实现“最小权限“原则
2. 服务端设置 `X-Frame-Options Header` 头，拒绝页面被嵌套，X-Frame-Options 是 HTTP 响应头中用来告诉浏览器一个页面是否可以嵌入 `<iframe>` 中

- eg.X-Frame-Options: SAMEORIGIN
- SAMEORIGIN: iframe 页面的地址只能为同源域名下的页面
- ALLOW-FROM: 可以嵌套在指定来源的 iframe 里
- DENY: 当前页面不能被嵌套在 iframe 里

3. 设置 CSP 即 `Content-Security-Policy` 请求头
4. 减少对 iframe 的使用

## HTTPS

描述：
黑客可以利用 SSL Stripping 这种攻击手段，强制让 HTTPS 降级回 HTTP，从而继续进行中间人攻击。

预防方案：
使用 HSTS（HTTP Strict Transport Security），它通过下面这个 HTTP `Header` 以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用 HTTPS，而不是通过明文的 HTTP 进行通信。这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起 HTTPS 请求，而不再像以往那样从 HTTP 跳转到 HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再
用户选择是否继续进行不安全的通信。

## 静态资源完整性校验

描述
使用 内容分发网络 (CDNs) 在多个站点之间共享脚本和样式表等文件可以提高站点性能并节省带宽。然而，使用 CDN 也存在风险，如果攻击者获得对 CDN 的控制权，则可以将任意恶意内容注入到 CDN 上的文件中 （或完全替换掉文件），因此可能潜在地攻击所有从该 CDN 获取文件的站点。

预防方案
将使用 base64 编码过后的文件哈希值写入你所引用的 `<script>` 或 标签的 integrity 属性值中即可启用子资源完整性能。

## 中间人攻击

中间人攻击（Man-in-the-middle attack, MITM），指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者窃听、篡改甚至完全控制。没有进行严格的证书校验是中间人攻击着手点。目前大多数加密协议都提供了一些特殊认证方法以阻止中间人攻击。如 SSL （安全套接字层）协议可以验证参与通讯的用户的证书是否有权威、受信任的数字证书认证机构颁发，并且能执行双向身份认证。攻击场景如用户在一个未加密的 Wi-Fi 下访问网站。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

场景

1. 在一个未加密的 Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络
2. Fiddler / Charles （花瓶）代理工具
3. 12306 之前的自己证书

过程

- 客户端发送请求到服务端，请求被中间人截获
- 服务器向客户端发送公钥
- 中间人截获公钥，保留在自己手上。然后自己生成一个【伪造的】公钥，发给客户端
- 客户端收到伪造的公钥后，生成加密 hash 值发给服务器
- 中间人获得加密 hash 值，用自己的私钥解密获得真秘钥,同时生成假的加密 hash 值，发给服务器
- 服务器用私钥解密获得假密钥,然后加密数据传输给客户端

使用抓包工具 fiddle 来进行举例说明

1. 首先通过一些途径在客户端安装证书
2. 然后客户端发送连接请求，fiddle 在中间截取请求，并返回自己伪造的证书
3. 客户端已经安装了攻击者的根证书，所以验证通过
4. 客户端就会正常和 fiddle 进行通信，把 fiddle 当作正确的服务器
5. 同时 fiddle 会跟原有的服务器进行通信，获取数据以及加密的密钥，去解密密钥

常见攻击方式

- 嗅探：嗅探是一种用来捕获流进和流出的网络数据包的技术，就好像是监听电话一样。比如：抓包工具
- 数据包注入：在这种，攻击者会将恶意数据包注入到常规数据中的，因为这些恶意数据包是在正常的数据包里面的，用户和系统都很难发现这个内容。
- 会话劫持：当我们进行一个网站的登录的时候到退出登录这个时候，会产生一个会话，这个会话是攻击者用来攻击的首要目标，因为这个会话，包含了用户大量的数据和私密信息。
- SSL 剥离：HTTPS 是通过 SSL/TLS 进行加密过的，在 SSL 剥离攻击中，会使 SSL/TLS 连接断开，让受保护的 HTTPS，变成不受保护的 HTTP（这对于网站非常致命）
- DNS 欺骗，攻击者往往通过入侵到 DNS 服务器，或者篡改用户本地 hosts 文件，然后去劫持用户发送的请求，然后转发到攻击者想要转发到的服务器
- ARP 欺骗，ARP(address resolution protocol)地址解析协议，攻击者利用 APR 的漏洞，用当前局域网之间的一台服务器，来冒充客户端想要请求的服务端，向客户端发送自己的 MAC 地址，客户端无从得到真正的主机的 MAC 地址，所以，他会把这个地址当作真正的主机来进行通信，将 MAC 存入 ARP 缓存表。
- 代理服务器

预防方案：

- 用可信的第三方 CA 厂商
- 不下载未知来源的证书，不要去下载一些不安全的文件
- 确认你访问的 URL 是 HTTPS 的，确保网站使用了 SSL，确保禁用一些不安全的 SSL，只开启：TLS1.1，TLS1.2
- 不要使用公用网络发送一些敏感的信息
- 不要去点击一些不安全的连接或者恶意链接或邮件信息
