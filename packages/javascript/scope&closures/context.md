---
title: 执行上下文
order: 2
---

## 调用栈

JavaScript 代码有两种类型：

1. **全局代码**，在所有函数外部定义；
2. **函数代码**，位于函数内部。JavaScript 引擎执行代码时，每一条语句都处于特定的执行上下文中。

既然具有两种类型的代码，那么就有两种执行上下文：全局执行上下文和函数执行上下文。二者最重要的差别是：全局执行上下文只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文；而函数执行上下文是在每次调用函数时，就会创建一个新的。

JavaScript 基于单线程的执行模型：在某个特定的时刻只能执行特定的代码。一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数。当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。所以需要跟踪执行上下文——正在执行的上下文以及正在等待的上下文。最简单的跟踪方法是使用执行上下文栈（或称为调用栈）。

```js
function skulk(ninja) {
  report(ninja + 'skulking');
}
function report(message) {
  console.log(message);
}

skulk('Kuma');
skulk('Yoshi');
```

执行上下文的行为如下：

1. 每个 JavaScript 程序只创建一个全局执行上下文，并从全局执行上下文开始执行（在单页应用中每个页面只有一个全局执行上下文）。当执行全局代码时，全局执行上下文处于活跃状态。
2. 首先在全局代码中定义两个函数：skulk 和 report，然后调用 skulk("Kuma")。由于在同一个特定时刻只能执行特定代码，所以 JavaScript 引擎停止执行全局代码，开始执行带有 Kuma 参数的 skulk 函数。创建新的函数执行上下文，并置入执行上下文栈的顶部。
3. skulk 函数进而调用 report 函数。又一次因为在同一个特定时刻只能执行特定代码，所以，暂停 skulk 执行上下文，创建新的 Kuma 作为参数的 report 函数的执行上下文，并置入执行上下文栈的顶部。
4. report 通过内置函数 console.log 打印出消息后，report 函数执行完成，代码又回到了 skulk 函数。report 执行上下文从执行上下文栈顶部弹出，skulk 函数执行上下文重新激活，skulk 函数继续执行。
5. skulk 函数执行完成后也发生类似的事情：skulk 函数执行上下文从栈顶端弹出，重新激活一直在等待的全局执行上下文并恢复执行。JavaScript 的全局代码恢复执行。

## 词法环境

**词法环境（lexicalenvironment）** 是 JavaScript 引擎内部用来跟踪标识符与特定变量之间的映射关系。

词法环境是 JavaScript 作用域的内部实现机制，人们通常称为**作用域** (scopes)。

通常来说，词法环境与特定的 JavaScript 代码结构关联，既可以是一个函数、一段代码片段，也可以是 try-catch 语句。这些代码结构（函数、代码片段、try-catch）可以具有独立的标识符映射表。

无论何时创建函数，都会创建一个与之相关联的词法环境，并存储在名为[[Environment]]的内部属性上（也就是说无法直接访问或操作）。两个中括号用于标志内部属性。

乍看之下会觉得奇怪。为什么不直接跟踪整个执行上下文，直接搜索与环境相匹配的标识符映射表呢？从技术上来说，在本例中是可行的。但是，需要记住的是，JavaScript 函数可以作为任意对象进行传递，**定义函数时的环境**与**调用函数的环境**往往是不同的（想一想闭包）。

无论何时调用函数，都会创建一个新的执行环境，被推入执行上下文栈。此外，还会创建一个与之相关联的词法环境。现在来看最重要的部分：外部环境与新建的词法环境，JavaScript 引擎将调用函数的内置[[Environment]]属性与创建函数时的环境进行关联。
