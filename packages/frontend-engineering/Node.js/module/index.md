---
title: 模块机制
group:
  order: 2
  title: Node.js 基础
---

## 前言

在 Node 中，模块分为两类

1.  **核心模块**: Node 提供的模块
2.  **文件模块**: 用户编写的模块

### 核心模块

**核心模块**部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编 译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。

```js
const fs = require('fs)
```

### 文件模块

**文件模块**则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

在 Node 中引入模块，需要经历如下 3 个步骤。

1. 路径分析
2. 文件定位
3. 编译执行

## 路径分析

**模块标识符**其实就是传递给 `require()` 方法的参数，它必须是符合小驼峰命名的字符串，或者 以`.`、`..`开头的相对路径，或者绝对路径。它可以没有文件名后缀`.js`。
模块标识符在 Node 中主要分为以下几类。

- 核心模块，如 `http`、`fs`、`path` 等。
- `.`或`..`开始的相对路径文件模块。
- 以`/`开始的绝对路径文件模块。
- 非路径形式的文件模块，如自定义的 connect 模块。

### 核心模块

```js
const fs = require('fs)
```

核心模块的优先级仅次于缓存加载，它在 Node 的源代码编译过程中已经编译为二进制代码， 其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了 一个 http 用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

### 文件模块

```js
const { add } = require('./math');
```

以`.`、`..` 和 `/` 开始的标识符，这里都被当做文件模块来处理。

在分析路径模块时，`require()`方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

### 第三方模块

```js
const _ = require('lodash');
```

模块路径是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。

```js
// paths.js

console.log(module.paths);
```

在 Linux 下，你可能得到的是这样一个数组输出:

```
[
  '/home/jackson/research/node_modules',
  '/home/jackson/node_modules',
  '/home/node_modules',
  '/node_modules'
]
```

在加载的过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。

## 文件定位

### 文件扩展名分析

CommonJS 模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node 会按`.js`、`.json`、`.node` 的次序补足扩展名，依次尝试。

### 目录分析和包

在分析标识符的过程中，`require()`通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时 Node 会将目录当做一个包来处理。

1. 在当前目录下查找`package.json`
2. 通过`JSON.parse()`解析出包描述对象
3. 从中取出 `main` 属性指定的文件名进行定位
4. 如果文件名缺少扩展名，将会进入扩展名分析的步骤

如果 `main` 属性指定的文件名错误，或者压根没有 `package.json` 文件，Node 会将 `index` 当做默认文件名，然后依次查找 `index.js`、`index.json`、`index.node`。

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

#### Reference

[How the module system, CommonJS & require works](https://blog.risingstack.com/node-js-at-scale-module-system-commonjs-require/)
